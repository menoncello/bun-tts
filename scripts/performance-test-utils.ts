/**
 * Performance Test Utilities
 * Utility functions for performance testing and report generation
 */

import { writeFileSync } from 'fs';
import type { TestResults, TestSummary, TestResult } from './performance-test-types.js';

/** Constants */
const MILLISECONDS_PER_SECOND = 1000;
const PERCENT_MULTIPLIER = 100;
const RATE_PRECISION = 100;
const MEMORY_PRECISION = 100;
const STANDARD_DEVIATION_POWER = 2;
const JSON_INDENTATION = 2;
const TARGET_SYNTHESIS_RATE = 10;
const SLOW_ADAPTER_NAME = 'slow-adapter';

/** Markdown report section constants */
const REPORT_TITLE = '# TTS Adapter Performance Test Report';
const PERFORMANCE_TARGETS_SECTION = '## Performance Targets';
const TEST_RESULTS_SECTION = '## Test Results';
const ISSUES_SECTION = '## Issues Identified';
const RECOMMENDATIONS_SECTION = '## Recommendations';
const TABLE_HEADERS = '| Adapter | Test | Category | Success Rate | Synthesis Rate | Response Time | Memory | Status |\n|---------|------|----------|--------------|----------------|---------------|---------|--------|\n';
const FOOTER = '\n---\n*Generated by TTS Adapter Performance Testing Suite*';
const SUCCESS_EMOJI = 'ðŸŽ‰ **No issues found!** All performance targets are being met.\n\n';
const PASS_STATUS = 'âœ… PASS';
const FAIL_STATUS = 'âŒ FAIL';

/**
 * Calculate standard deviation
 * @param {number[]} values - Array of numeric values
 * @returns {number} Standard deviation of the values
 */
export function calculateStandardDeviation(values: number[]): number {
  const avg = values.reduce((a, b) => a + b, 0) / values.length;
  const squareDiffs = values.map(value => Math.pow(value - avg, STANDARD_DEVIATION_POWER));
  const avgSquareDiff = squareDiffs.reduce((a, b) => a + b, 0) / squareDiffs.length;
  return Math.sqrt(avgSquareDiff);
}

/**
 * Calculate test statistics
 * @param {object} params - Statistics calculation parameters
 * @param {number[]} params.synthesisTimes - Array of synthesis times
 * @param {number[]} params.memoryUsages - Array of memory usages
 * @param {number} params.successCount - Number of successful iterations
 * @param {number} params.iterations - Total number of iterations
 * @param {number} params.wordCount - Word count of the text
 * @returns {TestResult['results']} Calculated statistics
 */
export function calculateStatistics({
  synthesisTimes,
  memoryUsages,
  successCount,
  iterations,
  wordCount,
}: {
  synthesisTimes: number[];
  memoryUsages: number[];
  successCount: number;
  iterations: number;
  wordCount: number;
}): TestResult['results'] {
  const avgSynthesisTime = synthesisTimes.reduce((a, b) => a + b, 0) / synthesisTimes.length;
  const avgSynthesisRate = wordCount / (avgSynthesisTime / MILLISECONDS_PER_SECOND);
  const avgMemoryUsage = memoryUsages.reduce((a, b) => a + b, 0) / memoryUsages.length;
  const successRate = (successCount / iterations) * PERCENT_MULTIPLIER;

  return {
    successCount,
    successRate,
    avgSynthesisTime: Math.round(avgSynthesisTime),
    avgSynthesisRate: Math.round(avgSynthesisRate * RATE_PRECISION) / RATE_PRECISION,
    avgMemoryUsage: Math.round(avgMemoryUsage * MEMORY_PRECISION) / MEMORY_PRECISION,
    minSynthesisTime: Math.min(...synthesisTimes),
    maxSynthesisTime: Math.max(...synthesisTimes),
    stdDeviation: calculateStandardDeviation(synthesisTimes),
  };
}

/**
 * Extract issues from assessment
 * @param {object} assessment - Performance assessment
 * @param {boolean} assessment.synthesis - Synthesis performance assessment
 * @param {boolean} assessment.responseTime - Response time assessment
 * @param {boolean} assessment.memory - Memory usage assessment
 * @param {boolean} assessment.quality - Quality score assessment
 * @returns {string[]} Array of issue strings
 */
export function extractIssues(assessment: {
  synthesis: boolean;
  responseTime: boolean;
  memory: boolean;
  quality: boolean;
}): string[] {
  const issues = [];
  if (!assessment.synthesis) issues.push('synthesis-rate');
  if (!assessment.responseTime) issues.push('response-time');
  if (!assessment.memory) issues.push('memory-usage');
  if (!assessment.quality) issues.push('quality-score');
  return issues;
}

/**
 * Generate performance recommendations
 * @param {TestResult[]} results - Array of test results
 * @returns {string[]} Array of recommendation strings
 */
export function generateRecommendations(results: TestResult[]): string[] {
  const recommendations = new Set<string>();

  addPerformanceRecommendations(results, recommendations);
  addAdapterSpecificRecommendations(results, recommendations);

  if (recommendations.size === 0) {
    recommendations.add('All performance targets are being met - continue monitoring');
  }

  return Array.from(recommendations);
}

/**
 * Add performance-based recommendations
 * @param {TestResult[]} results - Test results
 * @param {Set<string>} recommendations - Set to add recommendations to
 */
function addPerformanceRecommendations(results: TestResult[], recommendations: Set<string>): void {
  const synthesisRateIssues = results.filter(r => r.issues.includes('synthesis-rate')).length;
  const responseTimeIssues = results.filter(r => r.issues.includes('response-time')).length;
  const memoryIssues = results.filter(r => r.issues.includes('memory-usage')).length;

  if (synthesisRateIssues > 0) {
    recommendations.add(
      `Consider optimizing TTS engines for better synthesis rates (target: â‰¥${TARGET_SYNTHESIS_RATE} wps)`
    );
    recommendations.add('Review text preprocessing and formatting efficiency');
  }

  if (responseTimeIssues > 0) {
    recommendations.add(
      'Optimize response times by improving system resources and engine configuration'
    );
    recommendations.add('Consider implementing request queuing and load balancing');
  }

  if (memoryIssues > 0) {
    recommendations.add(
      'Monitor memory usage and implement memory leak detection'
    );
    recommendations.add('Consider reducing concurrent request limits');
  }
}

/**
 * Add adapter-specific recommendations
 * @param {TestResult[]} results - Test results
 * @param {Set<string>} recommendations - Set to add recommendations to
 */
function addAdapterSpecificRecommendations(results: TestResult[], recommendations: Set<string>): void {
  const slowAdapterResults = results.filter(r => r.adapterName === SLOW_ADAPTER_NAME);
  if (slowAdapterResults.some(r => !r.meetsTargets)) {
    recommendations.add(
      `The ${SLOW_ADAPTER_NAME} consistently fails to meet targets - consider optimization or replacement`
    );
  }
}

/**
 * Output results in JSON format
 * @param {TestResults} results - Test results
 * @param {import('./performance-test-types.js').PerformanceTestConfig} config - Test configuration
 */
export async function outputJsonResults(results: TestResults, config: import('./performance-test-types.js').PerformanceTestConfig): Promise<void> {
  const jsonOutput = JSON.stringify(results, null, JSON_INDENTATION);
  if (config.outputFile) {
    writeFileSync(config.outputFile, jsonOutput);
    // eslint-disable-next-line no-console
    console.log(`\nðŸ’¾ Results saved to: ${config.outputFile}`);
  } else {
    // eslint-disable-next-line no-console
    console.log('\nðŸ“Š Results:');
    // eslint-disable-next-line no-console
    console.log(jsonOutput);
  }
}

/**
 * Output results in Markdown format
 * @param {TestResults} results - Test results
 * @param {import('./performance-test-types.js').PerformanceTestConfig} config - Test configuration
 */
export async function outputMarkdownResults(results: TestResults, config: import('./performance-test-types.js').PerformanceTestConfig): Promise<void> {
  const markdownOutput = generateMarkdownReport(results);
  if (config.outputFile) {
    writeFileSync(config.outputFile, markdownOutput);
    // eslint-disable-next-line no-console
    console.log(`\nðŸ’¾ Results saved to: ${config.outputFile}`);
  } else {
    // eslint-disable-next-line no-console
    console.log('\nðŸ“Š Results:');
    // eslint-disable-next-line no-console
    console.log(markdownOutput);
  }
}

/**
 * Generate markdown report
 * @param {TestResults} results - Test results to report
 * @returns {string} Formatted markdown report string
 */
function generateMarkdownReport(results: TestResults): string {
  const { summary, results: testResults, recommendations } = results;

  let markdown = buildReportHeader(summary);
  markdown += buildPerformanceTargetsSection(summary.targets);
  markdown += buildTestResultsTable(testResults);
  markdown += buildIssuesSection(testResults);
  markdown += buildRecommendationsSection(recommendations);
  markdown += FOOTER;

  return markdown;
}

/**
 * Build report header
 * @param {TestSummary} summary - Test summary
 * @returns {string} Markdown header string
 */
function buildReportHeader(summary: TestSummary): string {
  return `${REPORT_TITLE}

**Generated:** ${new Date().toISOString()}
**Test Summary:** ${summary.passedTests}/${summary.totalTests} tests passed (${summary.passRate.toFixed(1)}%)

`;
}

/**
 * Build performance targets section
 * @param {import('../src/core/tts/adapters/performance-targets.js').PerformanceTargets} targets - Performance targets
 * @returns {string} Performance targets markdown section
 */
function buildPerformanceTargetsSection(targets: import('../src/core/tts/adapters/performance-targets.js').PerformanceTargets): string {
  return `${PERFORMANCE_TARGETS_SECTION}

- **Minimum Synthesis Rate:** ${targets.synthesis.minimum} words/second
- **Target Response Time:** ${targets.responseTime.shortTextMax}ms (short), ${targets.responseTime.mediumTextMax}ms (medium)
- **Maximum Memory Usage:** ${targets.memory.maxPerRequest}MB per request

`;
}

/**
 * Build test results table
 * @param {TestResult[]} testResults - Array of test results
 * @returns {string} Test results markdown table
 */
function buildTestResultsTable(testResults: TestResult[]): string {
  let table = `${TEST_RESULTS_SECTION}

${TABLE_HEADERS}`;

  for (const result of testResults) {
    const status = result.meetsTargets ? PASS_STATUS : FAIL_STATUS;
    table += `| ${result.adapterName} | ${result.testName} | ${result.category} | ${result.results.successRate.toFixed(1)}% | ${result.results.avgSynthesisRate} wps | ${result.results.avgSynthesisTime}ms | ${result.results.avgMemoryUsage}MB | ${status} |\n`;
  }

  return `${table}\n`;
}

/**
 * Build issues section
 * @param {TestResult[]} testResults - Array of test results
 * @returns {string} Issues markdown section
 */
function buildIssuesSection(testResults: TestResult[]): string {
  let section = `${ISSUES_SECTION}\n\n`;

  const failedResults = testResults.filter(r => !r.meetsTargets);
  if (failedResults.length === 0) {
    section += SUCCESS_EMOJI;
  } else {
    for (const result of failedResults) {
      section += `### ${result.adapterName} - ${result.testName}\n`;
      section += `- **Issues:** ${result.issues.join(', ')}\n`;
      section += `- **Impact:** ${result.assessment.details.join(' ')}\n\n`;
    }
  }

  return section;
}

/**
 * Build recommendations section
 * @param {string[]} recommendations - Array of recommendation strings
 * @returns {string} Recommendations markdown section
 */
function buildRecommendationsSection(recommendations: string[]): string {
  let section = `${RECOMMENDATIONS_SECTION}\n\n`;
  for (const recommendation of recommendations) {
    section += `- ${recommendation}\n`;
  }
  return `${section}\n`;
}